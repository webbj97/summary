(window.webpackJsonp=window.webpackJsonp||[]).push([[173],{925:function(e,n,p){"use strict";p.r(n);var a=p(50),l=Object(a.a)({},(function(){var e=this,n=e.$createElement,p=e._self._c||n;return p("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[p("h1",{attrs:{id:"plugin-插件"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#plugin-插件"}},[e._v("#")]),e._v(" plugin（插件）")]),e._v(" "),p("h2",{attrs:{id:"什么是plugin"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#什么是plugin"}},[e._v("#")]),e._v(" 什么是plugin？")]),e._v(" "),p("p",[e._v("插件 是 webpack 的 支柱 功能。Webpack 自身也是构建于你在 webpack 配置中用到的 相同的插件系统 之上！")]),e._v(" "),p("p",[e._v("插件目的在于解决 loader 无法实现的其他事。Webpack 提供很多开箱即用的 插件。")]),e._v(" "),p("p",[e._v("Tip\n如果在插件中使用了 webpack-sources 的 package，请使用 require('webpack').sources 替代 require('webpack-sources')，以避免持久缓存的版本冲突。")]),e._v(" "),p("p",[e._v("剖析\nwebpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 webpack compiler 调用，并且在 整个 编译生命周期都可以访问 compiler 对象。")]),e._v(" "),p("p",[e._v("ConsoleLogOnBuildWebpackPlugin.js")]),e._v(" "),p("p",[e._v("const pluginName = 'ConsoleLogOnBuildWebpackPlugin';")]),e._v(" "),p("p",[e._v("class ConsoleLogOnBuildWebpackPlugin {\napply(compiler) {\ncompiler.hooks.run.tap(pluginName, (compilation) => {\nconsole.log('webpack 构建正在启动！');\n});\n}\n}")]),e._v(" "),p("p",[e._v("module.exports = ConsoleLogOnBuildWebpackPlugin;\ncompiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中重复使用。")]),e._v(" "),p("p",[e._v("用法\n由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入一个 new 实例。")]),e._v(" "),p("p",[e._v("取决于你的 webpack 用法，对应有多种使用插件的方式。")]),e._v(" "),p("p",[e._v("配置方式\nwebpack.config.js")]),e._v(" "),p("p",[e._v("const HtmlWebpackPlugin = require('html-webpack-plugin');\nconst webpack = require('webpack'); // 访问内置的插件\nconst path = require('path');")]),e._v(" "),p("p",[e._v("module.exports = {\nentry: './path/to/my/entry/file.js',\noutput: {\nfilename: 'my-first-webpack.bundle.js',\npath: path.resolve(__dirname, 'dist'),\n},\nmodule: {\nrules: [\n{\ntest: /.(js|jsx)$/,\nuse: 'babel-loader',\n},\n],\n},\nplugins: [\nnew webpack.ProgressPlugin(),\nnew HtmlWebpackPlugin({ template: './src/index.html' }),\n],\n};\nProgressPlugin 用于自定义编译过程中的进度报告，HtmlWebpackPlugin 将生成一个 HTML 文件，并在其中使用 script 引入一个名为 my-first-webpack.bundle.js 的 JS 文件。")]),e._v(" "),p("p",[e._v("Node API 方式\n在使用 Node API 时，还可以通过配置中的 plugins 属性传入插件。")]),e._v(" "),p("p",[e._v("some-node-script.js")]),e._v(" "),p("p",[e._v("const webpack = require('webpack'); // 访问 webpack 运行时(runtime)\nconst configuration = require('./webpack.config.js');")]),e._v(" "),p("p",[e._v("let compiler = webpack(configuration);")]),e._v(" "),p("p",[e._v("new webpack.ProgressPlugin().apply(compiler);")]),e._v(" "),p("p",[e._v("compiler.run(function (err, stats) {\n// ...\n});\nTip\n你知道吗：以上看到的示例和 webpack 运行时(runtime)本身 极其类似。webpack 源码 中隐藏有大量使用示例，你可以将其应用在自己的配置和脚本中。")])])}),[],!1,null,null,null);n.default=l.exports}}]);