(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{876:function(t,a,_){"use strict";_.r(a);var s=_(50),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"设计模式-二-策略模式-待完善"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式-二-策略模式-待完善"}},[t._v("#")]),t._v(" 设计模式（二）策略模式（待完善）")]),t._v(" "),_("p",[t._v("条条大陆通罗马")]),t._v(" "),_("p",[t._v("程序设计也参考了这个原理，在实现某一个功能时，也有多种方案可以选择")]),t._v(" "),_("h2",{attrs:{id:"一、什么是策略模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是策略模式"}},[t._v("#")]),t._v(" 一、什么是策略模式")]),t._v(" "),_("h4",{attrs:{id:"_1-1-概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-概念"}},[t._v("#")]),t._v(" 1.1 概念")]),t._v(" "),_("p",[t._v("定义：定义一系列的算法，把他们封装起来，并且可以使它们相互替换。")]),t._v(" "),_("p",[t._v("不变的部分和变化的部分隔开是每个设计模式的主题")]),t._v(" "),_("p",[t._v("策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。\n在这个例子里，算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数额。而算\n法的实现是各异和变化的，每种绩效对应着不同的计算规则。\n一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体\n的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后\n把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用。\n现在用策略模式来重构上面的代码。")]),t._v(" "),_("h4",{attrs:{id:"_1-2-例子"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-例子"}},[t._v("#")]),t._v(" 1.2 例子")]),t._v(" "),_("h2",{attrs:{id:"二、策略模式的优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、策略模式的优缺点"}},[t._v("#")]),t._v(" 二、策略模式的优缺点")]),t._v(" "),_("p",[_("strong",[t._v("优点：")])]),t._v(" "),_("ol",[_("li",[t._v("策略模式利用组合、委托和多态等技术和思想，可以有效的避免多重条件选择语句")]),t._v(" "),_("li",[t._v("策略模式提供了对 开放-封闭 原则完美的支持，易于切换、易于理解、易于扩展")]),t._v(" "),_("li",[t._v("策略模式中的部分算法，也可以服用到其他地方")])]),t._v(" "),_("p",[_("strong",[t._v("缺点：")])]),t._v(" "),_("ol",[_("li",[t._v("策略模式会在程序中增加许多策略类，和策略对象")]),t._v(" "),_("li",[t._v("每一种策略都是要我们掌握的，也导致它们报漏在外")])])])}),[],!1,null,null,null);a.default=v.exports}}]);