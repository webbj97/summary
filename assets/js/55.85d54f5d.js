(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{809:function(n,e,l){"use strict";l.r(e);var t=l(50),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,l=n._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[l("p",[n._v("// 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。")]),n._v(" "),l("p",[n._v("// 示例：")]),n._v(" "),l("p",[n._v("// 输入：1->2->4, 1->3->4\n// 输出：1->1->2->3->4->4")]),n._v(" "),l("p",[n._v("var mergeTwoLists = function(l1, l2) {\nlet head = new Node('head');")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v("let prev = head;\nwhile(l1 !== null && l2 !== null){\n    if(l1.val < l2.val){\n        prev.next = l1;\n        l1 = l1.next; // l1 的指向后移1位\n    }else{\n        prev.next = l2;\n        l2 = l2.next; // l2 的指向后移1位\n    }\n    prev = prev.next;\n}\n// 当有一个链表先到达尾部后，剩下的接在末尾即可，也可能无空余节点，链接一个null\nprev.next = l1 === null ? l2 : l1;\nreturn head.next;\n")])])]),l("p",[n._v("}")])])}),[],!1,null,null,null);e.default=r.exports}}]);