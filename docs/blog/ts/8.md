# 八、类（Class）

> TypeScript 完全支持 ES2015 引入的 class 关键字。

## 1.基本用法

```ts
class Point {
    x: number; // 属性“x”没有初始化表达式，且未在构造函数中明确赋值。
    o!: string; // 你可以使用明确赋值断言操作符，来消减上面的错误（definite assignment assertion operator） !:
    y; // 成员“y”隐式包含类型“any”。
    z = 1; // Point.z: number 初始值的设置，会让Ts自动推断出它的类型
}

const point = new Point();
point.z = '1'; // 不能将类型“string”分配给类型“number”。
```

## 2.类属性

> readonly 字段可以添加一个 readonly 前缀修饰符，这会阻止在构造函数之外的赋值。

```ts
class Point {
    readonly r: number
    constructor(){
        this.r = 100;
    }
    setR(){
        this.r = 200; // 无法分配到 "r" ，因为它是只读属性。
    }
}

const point = new Point();
point.r = 200; // 无法分配到 "r" ，因为它是只读属性。ts
```

> Constructors 方法是类的默认构造函数方法，一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。
> 构造函数返回类实例类型

```ts
class Point {
    x: number;
    y: number;

    // Normal signature with defaults
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
}
```

> 取值函数（getter）和存值函数（setter）

在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。

```ts
class Point {
    get prop() {
        return "getter";
    }
    set prop(value) {
        console.log("setter: " + value);
    }
}

const inst = new Point();
inst.prop = '123'; // setter: 123
console.log(inst.prop); // getter
```

TypeScript 对存取器有一些特殊的推断规则：

* 如果 `get` 存在而 `set` 不存在，属性会被自动设置为 `readonly`
* 如果 `setter` 参数的类型没有指定，它会被推断为 `getter` 的返回类型

## 3.类的继承

### 3.1