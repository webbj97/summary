# 【Typescript入门手册】常见类型

> TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。
> TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。

<img src="https://img-blog.csdnimg.cn/ea9cdc30f83d43d99c5a10b7e76d5a0f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70" width="100%" />

相信大家经常会问到为什么会有Ts，我该不该学习Ts，在知乎上这样的问题也会受到大家广泛的关注，而我的回答是，该去了解，因为了解Ts不会像我们学习英语那样“痛苦”，如果TypeScript能够解决你的问题，那就继续深入的学习吧，本系列的第一篇文章也不会有太深奥的理论，花一些时间了解一下给出自己的判断吧～

话不多说，我们先来从基本类型入手，走进Ts的大门！

![在这里插入图片描述](https://img-blog.csdnimg.cn/0e89e4457f3243199adc51f43d6035af.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center)

## 一、变量上的类型注解（Type Annotations on Variables）

当你使用`const`、`var`、`let` 声明一个变量时，你可以选择性的添加一个类型注解，显式指定变量的类型：

```ts
let myName: string = "yuguang";
```

TypeScript 并不使用“在左边进行类型声明”的形式，比如 int x = 0；类型注解往往跟在要被声明类型的内容后面。

不过大部分时候，这不是必须的。因为 TypeScript 会自动推断类型。举个例子，变量的类型可以基于初始值进行推断：

```ts
// No type annotation needed -- 'myName' inferred as type 'string'
let myName = "yuguang";
```

大部分时候，**你不需要学习推断的规则**。如果你刚开始使用，尝试**尽可能少的使用类型注解**。你也许会惊讶于，TypeScript 仅仅需要很少的内容就可以完全理解将要发生的事情。

## 二、集本类型类型

JavaScript的类型分为两种：原始数据类型和对象类型。

原始数据类型包括：

* 布尔值
* 数值
* 字符串
* null
* undefined
* 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。

### 2.1 number、string、boolean

> 布尔值是最基础的数据类型，在TypeScript中，使用`boolean` 定义布尔值类型：\
> 注意；在TypeScript中，`boolean`是JavaScript中的基本类型，而`Boolean`是JavaScript中的构造函数。

```ts
let visible: boolean = false;
```


> 使用number来定义数值类型：

```ts
let age: number = 100;
```


> 使用`string`来定义字符串类型：

```ts
const name: string = '余光';
const templateName = `hi ${name}!`
```

### 2.2 空值、null、undefined

* JavaScript中没有空值`Void`的概念，在TypeScript中，可以用`void`表示没有任何返回值的函数;
* 声明一个`void`类型的变量没有什么用，因为你只能将它赋值为`undefined`和`null`;

```ts
function alertName(): void {
    alert('My name is Tom');
}

let unusable: void = 1;
// warning 不能将类型“number”分配给类型“void”。
// Type 'number' is not assignable to type 'void'.
```

* 在TypeScript中，可以使用 null 和 undefined 来定义这两个原始数据类型，但看起来没什么意义

```ts
let u: undefined = undefined;
let n: null = null;
```

与`void`的区别是，`undefined`和`null`是所有类型的子类型。也就是说`undefined`类型的变量，可以赋值给`number`类型的变量：

```ts
// 严格模式下，会报错
let num: number = undefined;
// 这样也不会报错
let u: undefined;
let num: number = u;
```

**注意:**

1. 声明变量的数据类型为 void 时，非严格模式下，变量的值可以为 undefined 或 null。而严格模式下，变量的值只能为 undefined。
2. 严格模式下：`let num: number = undefined;`会报错

![在这里插入图片描述](https://img-blog.csdnimg.cn/3f292f9f460046c9a4a6e65c245c45f6.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center)

## 三、任意值

> 如果你没有指定一个类型，TypeScript 也不能从上下文推断出它的类型，编译器就会默认设置为 any 类型。

TypeScript有一个特殊的类型`any`，当你不希望一个值导致类型检查错误的时候，就可以设置为`any`，先来看下面的代码：

```ts
let age:number = 100;

age = '余光'
// 不能将类型“string”分配给类型“number”
// Type 'string' is not assignable to type 'number'.
```

类型检测会提前帮我们规避一些不必要的风险，大家在平时也一定会遇到类型不匹配这样的错误，如果是`any`类型，则允许被赋值为任意类型。但写多了any和Js就没“区别”了不是吗？

```ts
let age:any = 100;

age = '余光';
```

### 3.1 任意值的属性和方法

* 在任意值上访问任何属性都是允许的；
* 调用任意方法也是允许的；

```ts
let anyThing: any = 'todo';
console.log(anyThing.myName);
console.log(anyThing.myName.firstName);

anyThing.toString();
```

可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。

### 3.2 未声明类型的变量在未指定其类型时会被识别为any

变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：

```ts
let something;
something = 'str';
something = 7;
something.name = '余光';

// 等价于
let something: any;
something = 'str';
something = 7;
something.name = '余光';
```

**注意:**

经过前面两点（尤其是第二点）的描述，你会发现如果给变量添加了`any`的声明，那么Typescript就变成了AnyScript了，那岂不是一夜回到了解放前？理论上我们尽量不使用any，就好像才出现了const和let之后，我们进来避免试用var一样。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b6dc499ae4834147a444455a65f30567.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center)

## 四、数组（未完成）

在TypeScript中，数组类型有多种定义方式，比较灵活。

### 4.1 类型 + 方括号

```ts
let fibonacci: number[] = [1, 1, 2, 3, 5]; // 此时数组内每个元素都会进行类型检测
```

数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：

```ts
let fibonacci: number[] = [1, 1, 2, 3, 5];
fibonacci.push('8'); // 类型“string”的参数不能赋给类型“number”的参数。
```

### 2.2 数组泛型

> 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。

我们可以使用数组泛型（Array Generic） `Array<elemType>` 来表示数组：


```ts
let fibonacci: Array<number> = [1, 1, 2, 3, 5];
```

其实两者非常相似～

### 2.3 用接口表示数组

接口也可以用来描述数组：

NumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。

```ts
interface NumberArray {
    [index: number]: number;
}
let fibonacci: NumberArray = [1, 1, 2, 3, 5];
```

看到接口有一种恍然大明白的感觉，数字也是特殊的对象，对象的属性是字符串类型，而数组的下标是数字类型，嗯没毛病

当然我们一般不会这么做，因为这种方式比前两种方式复杂多了。

不过有一种情况例外，那就是它常用来表示类数组。

### 2.4 类数组

类数组（Array-like Object）不是数组类型，比如 arguments：

```ts
function sum() {
    let args: number[] = arguments;
}

// 类型“IArguments”缺少类型“number[]”的以下属性: pop, push, concat, join 及其他 24 项
```

上例中，arguments实际上是一个类数组，不能用普通的数组的方式来描述，所以类型检测会提示缺少数组上的方法等等

而应该用接口：

```ts
function sum() {
    let args: {
        [index: number]: number;
        length: number;
        callee: Function;
    } = arguments;
}
```

在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 length 和 callee 两个属性。

事实上常用的类数组都有自己的接口定义，如`IArguments`, `NodeList`,`HTMLCollection` 等：

```ts
function sum() {
    let args: IArguments = arguments;
}
```

其中IArguments是TypeScript中定义好了的类型，它实际上就是：

```ts
interface IArguments {
    [index: number]: any;
    length: number;
    callee: Function;
}
```

### 2.5 any 在数组中的应用

一个比较常见的做法是，用 any 表示数组中允许出现任意类型：

```ts
let list: any[] = ['xcatliu', 25, { website: 'http://xcatliu.com' }];
```

对于any约束的数字，其实就是主动放弃了类型检测～



## 一、对象的类型（接口）

TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。简单的说，接口就是对**对象形状**的描述。

### 1.1 使用接口

来看下面一段代码：

```ts
function getName(obj: { name: string; age: number }): void {
  console.log(obj.name);
  console.log(obj.age);
}

const res = getName({ name: "余光", age: 100 });
console.log(res);
```

不难理解，我们将参数 obj 内部的属性进行了类型注释，并在之后检查对应的类型。

再来看看下面的代码：

```ts
interface Person {
  name: string;
  age: number;
}

function getName(person: Person): void {
  console.log(person.name);
  console.log(person.age);
}
const person1 = { name: "余光1", age: 100 };
const person2 = { name: "余光2", age: 200 };

getName(person1); // 余光1 100
getName(person2); // 余光2 200
```

开头我们提到过Ts的鸭式辨型法——像鸭子一样走路并且嘎嘎叫的就叫鸭子，在这里只要在结构（形状）是和接口Person一致的，就会通过类型检查。当然接口不仅仅只能这样使用，我们继续～

**注意：**

1. 定义的变量比接口少了一些属性是不允许的
2. 多一些属性也是不允许的

举例：

```ts
interface Person {
    name: string,
    age: number
}

// 缺少属性
const aa: Person = {
    name: '余光'
} // 类型 "{ name: string; }" 中缺少属性 "age"，但类型 "Person" 中需要该属性。

// 多属性
const aa: Person = {
    name: '余光',
    age: 100,
    height: 200
}
// 不能将类型“{ name: string; age: number; height: number; }”分配给类型“Person”。
// 对象文字可以只指定已知属性，并且“height”不在类型“Person”中。
```

### 1.2 可选属性

在1.1小节的最后我们知道，必须和接口的形状一模一样，但有时我们希望不要100%相似，这时就需要用到**可选属性**了

```js
interface Person {
    name: string;
    age?: number;
}

let person1: Person = {
    name: '余光'
};
```

注意可选属性可以不存在，但仍然不允许添加**未定义**的属性。

### 1.3 任意属性

有时候我们希望一个接口允许有任意的属性，可以使用如下方式：

```ts
interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let yuguang: Person = {
    name: '余光',
};
```

**注意：**一旦定义了任意属性，那么确定属性和可选属性的类型都**必须是它的类型的子集**：例如：

```ts
interface Person {
    name: string; // 类型“string”的属性“name”不能赋给字符串索引类型“number”
    age?: number; // 类型“number”的属性“age”不能赋给字符串索引类型“boolean”
    [propName: string]: boolean;
}

let yuguang: Person = {
    name: '余光',
    age: 100
};
```

**任意属性可以添加联合类型**

不难理解，任意属性的确定，是优先级最高的，确定的属性和可选属性会进行类型检测，所以才会有上面例子的检测错误，而想要避免这样的检测错误，可以给任意属性可以添加联合类

```ts
interface Person {
    name: string;
    age?: number;
    [propName: string]: string | number;
}
```

### 1.4 只读属性

有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用`readonly`定义只读属性：

```ts
interface Person {
    readonly id: number;
    name: string;
    age?: number;
    [propName: string]: any;
}

let yuguang: Person = {
    id: 1,
    name: '余光',
    gender: 'male'
};

yuguang.id = 9527; // 无法分配到 "id" ，因为它是只读属性。
```

注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：

```ts
interface Person {
    readonly id: number;
    name: string;
    age?: number;
    [propName: string]: any;
}

let yuguang: Person = {
    name: '余光',
    gender: 'male'
}; // 类型 "{ name: string; gender: string; }" 中缺少属性 "id"，但类型 "Person" 中需要该属性

yuguang.id = 9527; // 无法分配到 "id" ，因为它是只读属性。
```

你会发现：

1. 创建对象yuguang时应该被赋值的id属性不存在，会报错
2. id赋值的时会报错，因为这个属性是只读的

## 五、对象


## 六、函数

在函数是JavaScript中是一等公民，在Ts中，它允许我们指定输入类型和输出类型。

### 6.1 参数类型注解（Parameter Type Annotations）

当你声明一个函数的时候，你可以在每个参数后面添加一个类型注解，声明函数可以接受什么类型的参数。参数类型注解跟在参数名字后面：

**函数声明：**

```ts
function sum(x: number, y: number): number {
  return x + y;
}

// 输入多余的（或者少于要求的）参数，是不被允许的：

sum(1);
// 应有 2 个参数，但获得 1 个。ts(2554)

sum(1, 2, 3); 
// 应有 2 个参数，但获得 3 个
```

### 6.2 可选参数和参数默认值

前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？与接口中的可选属性类似，我们用`?`表示可选的参数：

**注意：**可选参数必须接在必需参数后面。换句话说，可选参数后面**不允许**再出现必需参数了。

```ts
function hello(name1: string, name2?: string): void {
  console.log(`hello! ${name1} ${name2 ? "and" + " " + name2 : ""}`);
}

hello("余光1", "余光2"); // hello! 余光1 and 余光2
hello("余光"); // hello! 余光
```

同样添加默认值也是可以的，TypeScript 会将添加了默认值的参数识别为可选参数：

```ts
function hello(name1: string = "余光", name2: string = "yuguang"): void {
  console.log(`hello! ${name1} ${name2 ? "and" + " " + name2 : ""}`);
}

hello(); // hello! 余光 and yuguang
hello("小明"); // hello! 小明 and yuguang
```

### 6.3 匿名函数

匿名函数有一点不同于函数声明，当 TypeScript 知道一个匿名函数将被怎样调用的时候，匿名函数的参数会被自动的指定类型。

这个例子来自“冴羽大佬”的示例👍

```js
const arr = [1, 2, 3, 4];

arr.forEach((val) => {
    val.toFixed(1);
});
// ✅

arr.forEach((val) => {
    val.split("-");
});
// ❌ 类型“number”上不存在属性“split”。
```

尽管参数`val`并没有添加类型注解，但TypeScript根据forEach函数的类型，以及传入的数据的类型，最后推断出了`val`的类型。

这个过程被称为上下文推断（contextual typing），因为正是从函数出现的上下文中推断出了它应该有的类型。

## 七、

## 写在最后

本篇文章是《Typescript基础入门》第三篇，到这里就结束了，主要带大家了解一下函数Ts中的表现，其实到这里有关一门语言中基础部分——类型相关的知识已经聊得差不多了（未来我们会讲到更多的进阶类型知识，例如泛型、别名、约束等），下一篇文章我们来聊一聊Ts中特殊的，或者说会让我们“陌生”的概念，希望大家通过这三篇文章能打消对Ts的抵触和迷茫，一起加油～

系列文章传送门：

1. [【Typescript入门手册】之基本类型在TypeScript中的应用](https://yuguang.blog.csdn.net/article/details/119137707)
2. [【Typescript入门手册】之引用类型在TypeScript中的应用](https://yuguang.blog.csdn.net/article/details/119220029)
3. 本篇


## 三、类型推论

> 如果没有明确的指定类型，那么TypeScript会依照类型**推论**（Type Inference）的规则推断出一个类型。

先来看看下面的代码：

```js
let age = 100;
age = '余光'; // 不能将类型“string”分配给类型“number”
```

<img src="https://img-blog.csdnimg.cn/1f52a88a2f0e477ca71aa0a4cc073997.png" width="50%" />

这是因为Ts会在没有明确指定类型的时候，根据赋值时数据类型推测出一个指定类型，这就是**类型推论**。

### 注意

如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成`any`类型而完全不被类型检查。

## 四、联合类型

> 联合类型（Union Types）表示取值可以为多种类型中的一种。

第一、二小节提到了基本类型的怎么指定的，如果你希望一个变量的类型是可选的可以试用any，但还有更好的方式就是明确指定几个类型——联合类型

```ts
let category: string | number;
category = 'seven';
category = 7;
category = true; // 不能将类型“boolean”分配给类型“string | number”。
```

联合类型使用 | 分隔每个类型。表示允许设置的类型

### 注意

当TypeScript不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：

```js
function getLength(something: string | number): number {
    return something.length;
}
```

<img src="https://img-blog.csdnimg.cn/1f859671f0fd41438cc1bf6cebc468d3.png" />

联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型，所以也会遇到上面问题

```ts
let val: string | number;
val = 'seven';
console.log(val.length); // 5
val = 7;
console.log(val.length); // 类型“number”上不存在属性“length”
```

此时如果你细心，你会发现：val是联合类型，而不会因为赋值而导致type类型变化

## 写在最后

本篇文章是《Typescript基础入门》第一篇，到这里就结束了，主要带大家了解一下常见类型在Ts中是什么样子的，大部分代码我们我们都认识，但组装起来却会有些别扭，一起共勉吧！

下一篇文章我们来聊一聊引用（对象、数组）类型在Ts中又会有什么不同呢？

- 花名：余光
- 邮箱：webbj97@163.com

### 其他沉淀

- [Github: Js版LeetCode题解](https://webbj97.github.io/leetCode-Js/)
- [前端进阶笔记](https://webbj97.github.io/summary/)
- [CSDN博客汇总](https://yuguang.blog.csdn.net/)

<p align=center>
	<img src="https://hlgcdn.oss-cn-hangzhou.aliyuncs.com/hlg-ui/1607504321645897/yuguang-vue-bottom.gif" width="100%"/>
</p>


