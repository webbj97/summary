# React 简介

React快速入门：https://zh-hans.reactjs.org/learn

一、初识React
React 应用程序是由 组件 组成的。一个组件是 UI（用户界面）的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。

React 组件是返回标签的 JavaScript 函数：
function MyButton() {
  return (
    <button>I'm a button</button>
  );
}
将上面的“组件”嵌套进新的组件，并导出一个组件
export default function MyApp() {
  return (
    <div>
      <h1>Welcome to my app</h1>
      <MyButton />
    </div>
  );
}

1.1 使用 JSX 编写标签
JSX 比 HTML 更加严格。你必须闭合标签，如 <br />。你的组件也不能返回多个 JSX 标签。且导出的组件只能返回一个根元素 或  Fragment（空标签）。


1.2 样式类名
与HTML相比，react内的类名使用className
1. {{ }}：这意味着内部变量是一个对象
2. 内联 style 属性 使用驼峰命名法编写。例如，HTML <ul style="background-color: black"> 在你的组件里应该写成 <ul style={{ backgroundColor: 'black' }}>。

二、数据通信
React 组件使用 props 来互相通信。每个父组件都可以提供 props 给它的子组件，从而将一些信息传递给它。
2.1 如何向组件传递 props 并读取
1. 将 props 传递给子组件 
2. 子组件中读取props
  a. 解构获取props内的目标属性
  b. 同理支持默认值


● 如何给组件传递 JSX
● Props 如何随时间变化

2.2 将 JSX 作为子组件传递
个人理解，他是一个 无具名 插槽！
将内容嵌套在 JSX 标签中时，父组件将在名为 children 的 prop 中接收到该内容。

可以将带有 children prop 的组件看作有一个“洞”，可以由其父组件使用任意 JSX 来“填充”。你会经常使用 children prop 来进行视觉包装：面板、网格等等。


三、条件渲染
在 React 中，你可以通过使用 JavaScript 的 if 语句、&& 和 ? : 运算符来选择性地渲染 JSX。

3.1 初识判断
function Item({ name, isPacked }) {
  return <li className="item">{name}{isPacked ? ' ✔' : ''}</li>;
}
3.2 短路判断
return (
  <li className="item">
    {name} {isPacked && '✔'}
  </li>
);
3.3 if判断切换变量和切换JSX都是可以的


四、列表渲染
注意key的作用用于比对虚拟Dom的改动



4.1 React 中为什么需要 key？ 
设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……
React 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。
五、保证组件的纯粹

● 只负责自己的任务。它不会更改在该函数调用前，就已存在的对象或变量。
● 输入相同，则输出相同。给定相同的输入，纯函数应总是返回相同的结果。
六、响应事件
响应：界面上的控件会根据用户的输入而更新。

PS可能要注意的地方：
1. 传递给事件处理函数的函数应直接传递，而非调用。
2. 对于处理逻辑，我们一般用handle开头
3. react的事件都会传播（冒泡）
6.1 添加事件处理函数 
如需添加一个事件处理函数，你需要先定义一个函数，然后 将其作为 prop 传入 合适的 JSX 标签。


6.2 将事件处理函数作为 props 传递 
通常，我们会在父组件中定义子组件的事件处理函数。比如：置于不同位置的 Button 组件，可能最终执行的功能也不同 —— 也许是播放电影，也许是上传图片。
为此，将组件从父组件接收的 prop 作为事件处理函数传递，如下所示：


6.3 命名事件处理函数 prop 
内置组件（<button> 和 <div>）仅支持 浏览器事件名称，例如 onClick。但是，当你构建自己的组件时，你可以按你个人喜好命名事件处理函数的 prop。
按照惯例，事件处理函数 props 应该以 on 开头，后跟一个大写字母。
例如，Button 组件的 onClick prop 本来也可以被命名为 onPlay：

6.4 摘要
● 你可以通过将函数作为 prop 传递给元素如 <button> 来处理事件。
● 必须传递事件处理函数，而非函数调用！ onClick={handleClick} ，不是 onClick={handleClick()}。
● 你可以单独或者内联定义事件处理函数。
● 事件处理函数在组件内部定义，所以它们可以访问 props。
● 你可以在父组件中定义一个事件处理函数，并将其作为 prop 传递给子组件。
● 你可以根据特定于应用程序的名称定义事件处理函数的 prop。
● 事件会向上传播。通过事件的第一个参数调用 e.stopPropagation() 来防止这种情况。
● 事件可能具有不需要的浏览器默认行为。调用 e.preventDefault() 来阻止这种情况。
● 从子组件显式调用事件处理函数 prop 是事件传播的另一种优秀替代方案。
七、了解State
组件通常需要根据交互更改屏幕上显示的内容。输入表单应该更新输入字段，单击轮播图上的“下一个”应该更改显示的图片，单击“购买”应该将商品放入购物车。组件需要“记住”某些东西：当前输入值、当前图片、购物车。在 React 中，这种组件特有的记忆被称为 state。

7.1 State 是隔离且私有的 
State 是屏幕上组件实例内部的状态。换句话说，如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！改变其中一个不会影响另一个。

● State 变量是通过调用 useState Hook 来声明的。它返回一对值：当前 state 和更新它的函数
● Hook 是以 use 开头的特殊函数。它们能让你 “hook” 到像 state 这样的 React 特性中。
● 组建可以拥有多个 state 变量。在内部，React 按顺序匹配它们。
● State 是组件私有的。如果你在两个地方渲染它，父组件无法更改它，则每个副本都有独属于自己的 state。

7.2  渲染和更新，和Vue对比是什么样的？
这是一个差异点？虚拟Dom比对存在差异，虽然都是提高渲染性能和抽象渲染过程

7.3 state 如同一张快照
也许 state 变量看起来和一般的可读写的 JavaScript 变量类似。但 state 在其表现出的特性上更像是一张快照。设置它不会更改你已有的 state 变量，但会触发重新渲染。
● 设置 state 如何导致重新渲染
● state 在何时以何种方式更新
● 为什么 state 不在设置后立即更新
● 事件处理函数如何获取 state 的一张“快照”
7.4 渲染会及时生成一张快照 
“正在渲染” 就意味着 React 正在调用你的组件——一个函数。你从该函数返回的 JSX 就像是 UI 的一张及时的快照。它的 props、事件处理函数和内部变量都是 根据当前渲染时的 state 被计算出来的。

但是，万一你想在重新渲染之前读取最新的 state 怎么办？你应该使用 状态更新函数，下一页将会介绍！

摘要：
● 当你调用 useState 时，React 会为你提供该次渲染 的一张 state 快照。
● 变量和事件处理函数不会在重渲染中“存活”。每个渲染都有自己的事件处理函数。
● 每个渲染（以及其中的函数）始终“看到”的是 React 提供给这个 渲染的 state 快照。
● 你可以在心中替换事件处理函数中的 state，类似于替换渲染的 JSX。
● 过去创建的事件处理函数拥有的是创建它们的那次渲染中的 state 值。
7.5 批处理
1. React 会等到事件处理函数中的 所有 代码都运行完毕再处理你的 state 更新

八、状态提升

结尾、react哲学
这是一段导词，我放在结尾，对react进行一个点题
React 可以改变你对可见设计和应用构建的思考。跟Vue相比，很多思想和书写习惯都存在一定的区别，当你使用 React 构建用户界面时，你首先会把它分解成一个个 组件，然后，你需要把这些组件连接在一起，使数据流经它们。这个Vue那种类HTML的结构存在很大的差异（JSX）
步骤一、将 UI 拆解为组件层级结构 
一开始，在绘制原型中的每个组件和子组件周围绘制盒子并命名它们。如果你与设计师一起工作，他们可能早已在其设计工具中对这些组件进行了命名。检查一下它们!
取决于你的使用背景，可以考虑通过不同的方式将设计分割为组件:
● 程序设计—使用同样的技术决定你是否应该创建一个新的函数或者对象。这一技术即 单一功能原理，也就是说，一个组件理想得仅做一件事情。但随着功能的持续增长，它应该被分解为更小的子组件。
● CSS—思考你将把类选择器用于何处。(然而，组件并没有那么细的粒度。)
● 设计—思考你将如何组织布局的层级。
如果你的 JSON 结构非常棒，经常会发现其映射到 UI 中的组件结构是一件自然而然的事情。那是因为 UI 和原型常拥有相同的信息结构—即，相同的形状。将你的 UI 分割到组件，每个组件匹配到原型中的每个部分。
步骤二: 使用 React 构建一个静态版本 
现在你已经拥有了你自己的组件层级结构，是时候实现你的应用程序了。最直接的办法是根据你的数据模型，构建一个不带任何交互的 UI 渲染代码版本…经常是先构建一个静态版本比较简单，然后再一个个添加交互。构建一个静态版本需要写大量的代码，并不需要什么思考; 但添加交互需要大量的思考，却不需要大量的代码。
构建应用程序的静态版本来渲染你的数据模型，将构建 组件 并复用其它的组件，然后使用 props 进行传递数据。Props 是从父组件向子组件传递数据的一种方式。(如果你对 state 章节很熟悉，不要在静态版本中使用 state 进行构建。state 只是为交互提供的保留功能，即数据会随着时间变化。因为这是一个静态应用程序，所以并不需要。)
你既可以通过从层次结构更高层组件 (如 FilterableProductTable) 开始 “自上而下” 构建，也可以通过从更低层级组件 (如 ProductRow) “自下而上” 进行构建。在简单的例子中，自上而下构建通常更简单；而在大型项目中，自下而上构建更简单。
步骤三: 发现 UI 精简且完整的 state 表示 
为了使 UI 可交互，你需要用户更改潜在的数据结构。你将可以使用 state 进行实现。
考虑将 state 作为应用程序需要记住改变数据的最小集合。组织 state 最重要的一条原则是保持它 DRY(不要自我重复)。计算出你应用程序需要的绝对精简 state 表示，按需计算其它一切。举个例子，如果你正在构建一个购物列表，你可将他们在 state 中存储为数组。如果你同时想展示列表中物品数量，不需要将其另存为一个新的 state。取而代之，可以通过读取你数组的长度来实现。
步骤四: 验证 state 应该被放置在哪里 
在验证你应用程序中的最小 state 数据之后，你需要验证哪个组件是通过改变 state 实现可响应的，或者 拥有 这个 state。记住：React 使用单向数据流，通过组件层级结构从父组件传递数据至子组件。要搞清楚哪个组件拥有哪个 state。如果你是第一次阅读此章节，可能会很有挑战，但可以通过下面的步骤搞定它!
为你应用程序中的每一个 state:
1. 验证每一个基于特定 state 渲染的组件。
2. 寻找它们最近并且共同的父组件——在层级结构中，一个凌驾于它们所有组件之上的组件。
3. 决定 state 应该被放置于哪里:
  a. 通常情况下，你可以直接放置 state 于它们共同的父组件。
  b. 你也可以将 state 放置于它们父组件上层的组件。
  c. 如果你找不到一个有意义拥有这个 state 的地方，单独创建一个新的组件去管理这个 state，并将它添加到它们父组件上层的某个地方。
步骤五: 添加反向数据流 
目前你的应用程序可以带着 props 和 state 随着层级结构进行正确渲染。但是根据用户的输入改变 state，需要通过其它的方式支持数据流: 深层结构的表单组件需要在 FilterableProductTable 中更新 state。
React 使数据流显式展示，是与双向数据绑定相比，需要更多的输入。如果你尝试在上述的例子中输入或者勾选复选框，发现 React 忽视了你的输入。这点是有意为之的。通过 <input value={filterText} />，已经设置了 input 的 value 属性，使之恒等于从 FilterableProductTable 传递的 filterText state。只要 filterText state 不设置，入的值就不会改变。
当用户更改表单输入时， state 将更新以反映这些更改。state 由 FilterableProductTable 所拥有，以只有它可以调用 setFilterText 和 setInStockOnly。使 SearchBar 更新 FilterableProductTable 的 state，需要将这些函数传递到 SearchBar:

